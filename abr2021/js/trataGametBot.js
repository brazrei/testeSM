//texto = "2020053016 - SBAZ GAMET VALID 301200/301800 SBGL-SBAZ AMAZONICA FIR BLW FL100SECN ISFC VIS: 1000 RA N OF S03 AND E OF W047 15/16 2000M RA N OF S07 AND S OF N01 AND W OF W047 AND E OF W0551000M RA N OF S05 AND S OF S01 AND W OF W056 AND E OF W063SIGWX : ISOL N OF S03 AND E OF W047ISOL N OF S07 AND S OF N01 AND W OF W047 AND E OF W055ISOL N OF S05 AND S OF S01 AND W OF W056 AND E OF W063SIG CLD : ISOL CB 3000/ABV 10000FT AGL N OF S03 AND E OF W047ISOL TCU 2700/ABV 10000FT AGL N OF S03 AND E OF W047ISOL CB 3000/ABV 10000FT AGL N OF S07 AND S OF N01 AND W OF W047 AND E OF W055ISOL TCU 2700/ABV 10000FT AGL N OF S07 AND S OF N01 AND W OF W047 AND E OF W055ISOL CB 3000/ABV 10000FT AGL N OF S05 AND S OF S01 AND W OF W056 AND E OF W063ISOL TCU 2700/ABV 10000FT AGL N OF S05 AND S OF S01 AND W OF W056 AND E OF W06312/14 BKN 400/800FT AGL N OF S10 AND S OF S03 AND W OF W06212/14 BKN 400/800FT AGL N OF S01 AND E OF W060 AND W OF W050SIGMET APPLICABLE: 7,8SECN IIPSYS : NILWIND/T : 2000 FT 070/11KT PS285000 FT 080/13KT PS2210000 FT 110/10KT PS10CLD : BKN CU 2700/8000FT AGL N OF S09SCT AC 9000/ABV 10000FT AGL N OF S08QNH: 1015HPASEA: T29 HGT 1.6MVA: NIL="
//texto = "2020053016 - SBRE GAMET VALID 301200/301800 SBGL-SBRE RECIFE FIR BLW FL100SECN ISFC VIS: 1200 RABR N OF S11 AND S OF S06 AND E OF W035 AND W OF W03320/22 4500M RA S OF S12 AND N OF S15 AND E OF W040SIGWX: ISOL TS N OF S11 AND S OF S06 AND E OF W035 AND W OF W033SIG CLD: ISOL CB 2700/ABV 10000FT AGL N OF S11 AND S OF S06 AND E OF W035 AND W OF W033ISOL TCU 2700/ABV 10000FT AGL N OF S11 AND S OF S06 AND E OF W035 AND W OF W033ISOL TCU 2700/ABV 10000FT AGL S OF S12 AND N OF S15 AND E OF W04012/15 BKN 700/900FT AGL S OF S06 AND N OF S10 AND E OF W037SIGMET APPLICABLE: 3SECN IIPSYS: NILWIND/T: 2000FT 100/14KT PS255000FT 090/09KT PS1910000FT 070/16KT PS10CLD: SCT AC 9000/ABV 10000FT AGLBKN CU 2300/5000FT AGL E OF W041QNH: 1015HPASEA: T29 HGT 1.6MVA: NIL="
//texto = "2020053101 - SBAZ GAMET VALID 310000/310600 SBGL-SBAZ AMAZONICA FIR BLW FL100SECN ISIGWX: ISOL TSMT OBSC: DIVISORSIG CLD: ISOL EMBD TCU/CB 3000/ABV 10000FT AGL/AMSLSECN IIPSYS: NILWIND/T: 2000FT 070/12KT PS23 5000FT 070/20KT PS18 10000FT 090/16KT PS09CLD: SCT CU 2300/7000FT AGL/AMSLFZLVL: ABV 10000FT AGLMNM QNH: 1012 HPASEA: T29 HGT 1,8MVA: NIL="
//texto  = "2020053101 - SBBS GAMET VALID 310000/310600 SBGL-SBBS BRASILIA FIR BLW FL100SECN IHAZARDOUS WX NILSECN IIPSYS: NILWIND/T: 2000FT 100/15KT PS23 5000FT 070/13KT PS17 10000FT 350/08KT PS10CLD: BKN SC 1500/5000FT AGL N OF S12FZLVL: ABV 10000FT AGLMNM QNH: 1013 HPAVA: NIL="
//texto = "2020053101 - SBRE GAMET VALID 310000/310600 SBGL-SBRE RECIFE FIR BLW FL100SECN ISFC VIS: 03/06 3000M RA N OF S13SIGWX: ISOL TS N OF S13SIG CLD: ISOL CB 3000/ABV 10000FT AGL/AMSL N OF S13ISOL TCU 2500/ABV 10000FT AGL/AMSL N OF S13BKN 900/1400FT AGL/AMSL N OF S13SECN IIPSYS: NILWIND/T: 2000FT 160/16KT PS23 5000FT 140/16KT PS17 10000FT 090/12KT PS10CLD: SCT CUSC 1500/5000FT AGL/AMSLFZLVL: ABV 10000FT AGL/ AMSLMNM QNH: 1012HPASEA: T29 HGT 1,4MVA: NIL="
//texto = "2020053101 - SBCW GAMET VALID 310000/310600 SBGL -SBCW CURITIBA FIR BLW FL100SECN ISFC VIS: 02/06 3000M RA S OF S28 AND W052SIGWX: NILSIG CLD: 02/06 BKN 900/1400FT AGL S OF S28 AND W052SECN IIPSYS: NILWIND/T: 2000FT 190/18KT PS19 5000FT 280/12KT PS15 10000FT 290/34KT PS07CLD: BKN CU 2000/6500FT AGL S OF S28 AND W052AGL FZLVL: ABV 10000FT AGL/AMSLMNM QNH: 1016HPAVA: NIL="
//texto = "2020053115 - SBAZ GAMET VALID 311200/311800 SBGL-SBAZ AMAZONICA FIR BLW FL100SECN ISFC VIS: 2000M RA N OF S06SIGWX:ISOL TS N OF S13SIG CLD:12/15 BKN 800/1500FT AGL N OF S1316/17 ISOL EMBD CB 3000/ABV 10000FT AGL N OF S1318/22ISOL EMBD TCU 2000/ABV 10000FT AGL/AMSL N OF S13SECN IIPSYS: NILWIND/T:2000FT: 100/10KT PS22 5000FT: 090/14KT PS17 10000FT: 090/17KT PS09CLD:BKN AS 9000/ABV 10000FT AGL/AMSL N OF S10FZLVL: ABV 10000FT AGL/ AMSLMNM QNH:1011HPASEA:T29 HGT 1,4MVA:NIL= "
//texto = "2020053115 - SBBS GAMET VALID 311200/311800 SBGL-SBBS BRASILIA FIR BLW FL100SECN IHARZARDOUS WX NILSECN IIPSYS: H 1022HPA MOV E 04KT NC S1908 W04536WIND/T:030/16KT PS24 5000FT 350/10KT PS18 10000FT 070/07KT PS10CLD:SCT CU 2000/7000FT AGLFZLVL: ABV 10000FT AGLMNM QNH: 1014HPAVA: NIL="
//texto = "2020053115 - SBRE GAMET VALID 311200/311800 SBGL-SBRE RECIFE FIR BLW FL100SECN ISFC VIS:12/15 2000M RA N OF S11SIGWX:ISOL TS N OF S11SIG CLD:I12/15 BKN 800/1500FT AGL N OF S11ISOL EMBD CB 3000/ABV 10000FT AGL N OF S11ISOL EMBD TCU 2500/ABV 10000FT AGL/AMSL N OF S11SECN IIPSYS: NILWIND/T:2000FT 160/15KT PS22 5000FT 140/12KT PS15 10000FT 080/11KT PS10CLD:BKN CU 1800/5000FT AGL/AMSL BKN AS 6000/ ABV 10000FT AGL/AMSLFZLVL: ABV 10000FT AGL/ AMSLMNM QNH: 1013HPASEA:T29 HGT 1,4MVA: NIL="
//texto = "2020053115 - SBCW GAMET VALID 311200/311800 SBGL -SBCW CURITIBA FIR BLW FL100SECN ISFC VIS: 3000M RA S OF S25 AND W049SIGWX: NILSIG CLD: BKN 900/1400FT AGL S OF S25 AND W049SECN IIPSYS: FRONT MOV E 15KT INTSF S2840 W05230 TO S2840 W04950WIND/T:2000FT: 160/13KT PS19 5000FT: 270/36KT PS16 10000FT: 260/45KT PS09CLD: BKN CU 1800/5000FT AGL S OF S28 AND W050 BKN AS 6000/ ABV 10000FT AGL S OF S28 AND W050FZLVL: ABV 10000FT AGLMNM QNH:1012HPAVA:NIL="
//texto = "SBCW GAMET VALID 091800/092400 SBPA - SBCW CURITIBA FIR BLW FL100 SECN I SFC WIND: 090/31KT S OF S23 AND N OF S30 SFC VIS: 1300/5000M RA BR S OF S23 AND N OF S30 SIGWX: ISOL EMBD TS S OF S23 AND N OF S30 MT OBSC: SERRA DO MAR SERRA GERAL SIG CLD: EMBD CB/TCU 3000/ABV 10000FT AGL S OF S23 AND N OF S30 BKN 300/3000FT AGL SECTORS S OF S23 AND N OF S30 SECN II PSYS:18 NIL WIND/T: 2000FT: 100/05KT PS25 5000FT: 090/05KT PS18 10000FT: 240/05KT PS05 CLD: SCT/BKN CUSC 2000/6500FT AGL S OF S23 AND N OF S33 SCT/BKN ACAS 7000/ABV 10000FT S OF S23 AND N OF S33 AGL FZLVL: ABV 10000FT AMSL MNM QNH: 1012HPA VA:NIL="


arrRangeVis = []
arrayStatusGamet = []
regNuvem = { nome: "", validade: "", base: "", topo: "", area: "", areaStr: "" }

arrNuvemFIR = []
arrNuvensNames = ["BKN", "OVC", "ISOLCB/TCU", "ISOLTCU/CB", "ISOLTCU", "ISOLCB", "ISOLEMBDTCU/CB", "ISOLEMBDCB/TCU", "ISOLEMBDCB", "ISOLEMBDTCU", "EMBDTCU/CB", "EMBDCB/TCU", "EMBDCB", "EMBDTCU", "OCNLTCU/CB", "OCNLCB/TCU", "OCNLCB", "OCNLTCU", "OBSCTCU/CB", "OBSCCB/TCU", "OBSCCB", "OBSCTCU", "FRQTCU/CB", "FRQCB/TCU", "FRQCB", "FRQTCU", "CB", "TCU"]

arrNuvensNamesOk = ["BKN", "OVC", "ISOL CB/TCU", "ISOL TCU/CB", "ISOL TCU", "ISOL CB", "ISOL EMBD TCU/CB", "ISOL EMBD CB/TCU", "ISOL EMBD CB", "ISOL EMBD TCU", "EMBD TCU/CB", "EMBD CB/TCU", "EMBD CB", "EMBD TCU", "OCNL TCU/CB", "OCNL CB/TCU", "OCNL CB", "OCNL TCU", "OBSC TCU/CB", "OBSC CB/TCU", "OBSC CB", "OBSC TCU", "FRQ TCU/CB", "FRQ CB/TCU", "FRQ CB", "FRQ TCU", "CB", "TCU"]

regVis = { validade: "", valor: "", area: "", areaStr: "" }
//arrVis = [regVis]
arrVisFIR = []

globalValidadeTeto = ""

function removeEspacos(texto) {
  texto = texto.replace(/ /g, "");
  return texto
}

function removeEspacosDuplos(texto) {

  while (texto.includes("  "))
    texto = texto.replace(/  /g, " ");
  return texto
}

function truncLatLong(str) {
  function trunca(patt) {
    var v = str.match(patt)

    for (var i in v) {
      var s = v[i]
      str = str.replace(s, s.substr(0, s.length - 2))
    }
    return str
  }
  var pattLong = /\D OF [A-Z](\d{5})/g;
  trunca(pattLong)
  var pattLat = /\D OF [A-Z](\d{4})/g;
  trunca(pattLat)

  //trunca as longitudes
  //console.log("testando ==> "  +v1)
  return str
}
function insereM(str) {
  var arrTP = ["FG", "BR", "SA", "DU", "HZ", "FU", "VA", "PO", "DS", "SS", "DZ", "RA", "SN", "SG", "FC", "GR", "GS", "PL", "SQ"]
  var patt = /\d{4} /g
  //console.log("insereM  (str)= "+str)

  str2 = str.match(patt)
  //console.log("insereM (str2) = "+str2)
  for (var i in arrTP) {
    for (var j in str2) {
      var auxStr = str2[j] + arrTP[i]
      var auxStr2 = str2[j].substr(0, str2[j].length - 1) + "M " + arrTP[i]
      str = str.replace(auxStr, auxStr2)
      //console.log(auxStr)
      //console.log(auxStr2)
    }
  }
  //console.log("insereM = "+str)
  return str;
}

function decodificaRangeVis(vis) {
  for (var i in arrRangeVis) {

    var idx = 9900 + (i * 10);
    //arrRangeVis.push(v[i]) //cria um indice das visibilidades codificadas
    var aux = arrRangeVis[i]
    vis = vis.replace(idx + "M", aux)
    //console.log("decodRange aux== >" + aux)
    //console.log("decodRange vis== >" + vis)
  }
  return vis
}

function codificaRangeVis(vis) {
  arrRangeVis.length = 0
  var visPatt = /\d{4}\/(\d{4}M)/g;
  var v = vis.match(visPatt)
  //console.log("codRange v== >" + v)
  for (var i in v) {
    //console.log("codRange i== >" + i)

    var idx = 9900 + (i * 10);
    //console.log("codRange idx== >" + idx)
    arrRangeVis.push(v[i]) //cria um indice das visibilidades codificadas
    var aux = v[i]
    vis = vis.replace(aux, (idx) + aux.substr(aux.length - 1))
    //console.log("codRange aux== >" + aux)
    //console.log("codRange vis== >" + vis)
  }
  return vis
}

function forca4dVis(vis) {
  for (var i = 1; i < 10; i++) {
    while (vis.indexOf(" " + i) > -1)
      vis = vis.replace(" " + i, "0" + i)
  }
  return vis;
}

function filtraValidadeZulu(texto) {
  let valPatt = /\d{2}\/\d{2}Z/g;

  let arrValidVis = texto.match(valPatt)
  for (var i in arrValidVis){ 
    let validz = arrValidVis[i]
    let validx = validz.replace("Z","")
    while (texto.includes(validz))
    { 
      texto = texto.replace(validz, validx)
    }

  }
  return texto
}

function getVisGamet(texto, idxFIR) {
  texto = removeEspacosDuplos(texto);
  texto = filtraValidadeZulu(texto)
  texto = texto.replace(/ :/g, ":");
  //texto = truncLatLong(texto)
  texto = removeEspacosDuplos(texto);
  var arrVis = [regVis]

  arrVis.length = 0;
  texto = insereM(texto)
  texto = extractSigVis(texto)

  //console.log("---)"+texto)
  if (texto.includes("SFC VIS: NIL"))
    return ""

  vis = texto.split("VIS:")[1].split(":")[0];
  //vis = forca4dVis(vis);
  //console.log(vis)
  // falta buscar pelo campo de validade opicional
  // nuvPatt =  /\d{2}\/\d{2}[A-Z]/g; //PEGA O intervalo de validade de str sem espaços
  //console.log("vis0 ==> " + vis)
  vis = codificaRangeVis(vis)
  visEspaco = vis + ""
  vis = vis.replace(/ /g, "");
  //console.log("vis1 ==> " + vis)
  var visPatt = /(\d{4}M[A-Z][A-Z])/g;
  v = vis.match(visPatt)
  //console.log("v ==> " + v)

  //separa as validades

  var valPatt = /\d{2}\/\d{2} /g;

  var arrValidVis = visEspaco.match(valPatt)
  for (var i in arrValidVis)
    visEspaco = visEspaco.split(arrValidVis[i]).join("A%%" + arrValidVis[i] + "A%%")

  //console.log("arrValid ==> " + arrValidVis)

  //separa em grupos de validade
  if (vis.substr(1, 5).indexOf("/") < 0)
    visEspaco = "A%%00/00A%%" + visEspaco
  var arrVisEspaco = visEspaco.split("A%%")
  //console.log("vespaco ==> " + arrVisEspaco)
  var auxValid = ""
  var auxVis = ""
  for (var c in arrVisEspaco) {
    if (arrVisEspaco[c].substr(1, 5).indexOf("/") > 0)
      auxValid = arrVisEspaco[c]
    else if ((arrVisEspaco[c].length > 6) && !arrVisEspaco[c].includes("/"))
      auxVis = auxVis + arrVisEspaco[c] + "**" + auxValid + "**"

  }
  vis = auxVis.replace(/ /g, "") + ""
  //console.log("auxVis = >  " + auxVis)
  //strCoord = vis.split("0M")
  //console.log("strcoord =>"+strCoord)
  //for (var c in arrVisEspaco) 
  {
    //v = arrVisEspaco[c]
    //console.log("***" + v)
    //console.log("***" + vis)
    //if (arrVisEspaco[c].length>10) 
    {
      if (!v) v = "";
      for (i = 0; i < v.length; i++) {
        //console.log (v.length)
        if (v[i][4] !== "M") {
          var oldv = v[i].substr(0, v[i].length - 1) //nunca mexer aqui sem saber o que está fazendo.
          v[i] = v[i].substr(0, 4) + "M" + v[i].substr(4, 2);
          vis = vis.replace(oldv, v[i])
        }

        //verifica se acabaram as previsoes dentro de determinada validade
        while (vis.indexOf(v[i]) > vis.indexOf("**")) {
          vis = vis.split("**").splice(1).join("**")
        }
        //

        var auxVal = vis.split("**")[1]

        var coord = ""
        coord = vis.split(v[i])[0]
        vis = vis.split(v[i]).splice(1).join(v[i])

        v[i] = v[i].split("M").join("M ") //insere espaço depois do M
        v[i] = decodificaRangeVis(v[i])
        coord = coord.replace(/AND/g, "") //retira os AND

        coord = putSpaceCoord(coord) //separa novamente as coordenadas
        arrVis.push({ validade: auxVal, valor: v[i], area: getLatLon(coord), areaStr: coord.split("**")[0] })
      }
    }
  }
  //console.log(v)
  //console.log(arrVis)
  arrVisFIR[idxFIR] = arrVis
  return arrVis
}

function limpaCoord(str) {
  return str.replace("N 0F ", "N OF ").replace("S 0F ", "S OF ").replace("E 0F ", "E OF ").replace("W 0F ", " W OF ");
}

function putSpaceCoord(str) {
  str = str.replace("NOF", " N OF ").replace("SOF", " S OF ").replace("EOF", " E OF ").replace("WOF", " W OF ");
  return str.replace("N0F", " N OF ").replace("S0F", " S OF ").replace("E0F", " E OF ").replace("W0F", " W OF ");

}

function getLatLon(s, returnStr = false) {
  str = ""
  var auxStrLatLon = ""
  if (s.includes(" IN "))
    str = " IN "
  else if (s.includes(" WI "))
    str = " WI "

  valVis = s.split(str)[0]
  if (s.includes("E OF ")) {
    var auxs = (s.split("E OF ")[1]).substr(1, 3)
    var lon1 = auxs * -1
    auxStrLatLon = auxStrLatLon + " E OF W" + auxs
  }
  else
    var lon1 = -999

  if (s.includes("W OF ")) {
    var auxs = (s.split("W OF ")[1]).substr(1, 3)
    var lon0 = auxs * -1
    auxStrLatLon = auxStrLatLon + " W OF W" + auxs
  }
  else
    var lon0 = 999

  if (s.includes("S OF ")) {
    s1 = s.split("S OF ")[1]
    auxStrLatLon = auxStrLatLon + " S OF " + s1.substr(0, 3)
    var lat0 = (s1).substr(1, 2)
    if (s1[0] == ("S"))
      lat0 = lat0 * -1
    else
      lat0 = lat0 * 1
  }
  else
    var lat0 = 999

  if (s.includes("N OF ")) {
    s1 = s.split("N OF ")[1]
    auxStrLatLon = auxStrLatLon + " N OF " + s1.substr(0, 3)
    var lat1 = (s1).substr(1, 2)
    if (s1[0] == ("S"))
      lat1 = lat1 * -1
    else
      lat1 = lat1 * 1
  }
  else
    var lat1 = -999

  //return "lat = " + lat0+ "/"+lat1 + "--- long =" + lon0+"/"+lon1
  //console.log("latlon" + auxStrLatLon)
  if (returnStr)
    return auxStrLatLon
  else
    return { lat0: lat0, lat1: lat1, lon0: lon0, lon1: lon1, texto: auxStrLatLon }

}

function getValidades(texto) {
  t = texto.replace(/ /g, "");
  //console.log("t => " + t )

  nuvPatt2 = /\d{2}\/\d{2}[A-Z]/g; //PEGA O intervalo de validade de str sem espaços


  return t.match(nuvPatt2)
}

function getValidTxt(texto) {
  nuvPatt2 = /\d{2}\/\d{2}/g; //PEGA O intervalo de validade de str sem espaços
  texto = texto.match(nuvPatt2)
  if (texto)
    return texto[0]
  else
    return ""
}

function getValid(texto) {
  t = getValidades(texto)
  //console.log("t => " + t )
  if (t == null)
    return -1

  t = t[0] + ""
  t = t.substr(0, 5)
  return t
}

function getIndexValid(texto) {
  t = getValid(texto)
  //console.log("t => " + t )
  return texto.indexOf(t)
}

function getNuvemName(texto) {
  //BKN ou OVC [n]nnn/[n]nnnM (FT) AGL ou AMSL 
  //ISOL ou OCNL ou FRQ ou OBSC ou EMBD CB2ou TCU2[n]nnn/[n]nnnM (FT) AGL ou AMSL
  var texto = texto.replace(/ /g, "");
  var camada = texto.split("FT")[0]
  //console.log("camada = "+camada)
  //console.log(arrNuvensNames)
  for (var i = 0; i < arrNuvensNames.length; i++) {
    idx = camada.indexOf(arrNuvensNames[i])
    //console.log(idx + " ==> " + arrNuvensNames[i])
    if (idx > -1) {
      return arrNuvensNamesOk[i]
    }
  }
  return ""
}

function extractSigCld(texto) {
  if (!texto.includes("SIG CLD:"))
    return "SIG CLD: NIL"
  nuvens = texto.split("SIG CLD:")[1].split(":")[0];
  nuvens = nuvens.split("SECN")[0];
  nuvens = nuvens.split("SIGMET")[0];
  nuvens = nuvens.split("MTW:")[0];
  nuvens = nuvens.split("TURB:")[0];
  nuvens = nuvens.split("ICE:")[0];

  return nuvens
}
function extractSigVis(texto) {
  //console.log(texto)
  if (!texto.includes("VIS:"))
    return "SFC VIS: NIL"

  var vis = texto.split("VIS:")[1].split(":")[0];
  //console.log(vis)

  vis = vis.split("SECN")[0];
  vis = vis.split("SIGMET")[0];
  vis = vis.split("MTW")[0];
  vis = vis.split("TURB")[0];
  vis = vis.split("ICE")[0];
  vis = vis.split("MT OBSC")[0];
  vis = vis.split("SIGWX")[0];


  //console.log(vis)

  return "SFC VIS: " + vis
}

function getTetoGamet(nuvem) {
  //arrNuvens.length = 0
  var base = 0
  var topo = 0
  var nome = ""
  nuvemName = getNuvemName(nuvem);
  nuvens = nuvem
  nuvPattTopo = /\d{4}FT/g; //PEGA O TOPO
  nuvPattBase = /\d{4}\//g; // pega a base

  var camada = nuvens.split("0FT")[0] + "0FT"
  //console.log(camada)

  var base = camada.match(nuvPattBase);
  if (base)
    base = base[0]

  var topo = camada.match(nuvPattTopo);

  if (topo)
    topo = topo[0]

  if (base == null) { //base com apenas 3 dígitos
    nuvPattBase = /\d{3}\//g; // pega a base

    base = camada.match(nuvPattBase);
    if (base)
      base = base[0]
  }

  if (topo == null) { //topo com apenas 3 dígitos
    nuvPattTopo = /\d{3}FT/g; //PEGA O TOPO
    topo = camada.match(nuvPattTopo);
    if (topo)
      topo = topo[0]
  }

  base = base.replace(/\D/g, '');
  if (topo == "0000FT")
    topo = "ABV 10000FT"
  else
    topo = topo.replace(/\D/g, '');
  validade = ""

  nuvem = limpaCoord(nuvem)
  var area = getLatLon(nuvem)
  //arrNuvens.push()
  return { nome: nuvemName, validade: globalValidadeTeto, base: base, topo: topo, area: area, areaStr: nuvem };
}

function extractCoordNuvem(camada) {
  return getLatLon(camada, true)
}

function removeCoordNuvem(camada) {

}

function mascaraCBTCU(texto) {
  return texto.replace(/CB/g, "CXXXB").replace(/TCU/g, "TXCXU");
}

function desmascaraCBTCU(texto) {
  return texto.replace(/CXXXB/g, "CB").replace(/TXCXU/g, "TCU");
}

function getNuvensGamet(texto, idxFIR) {
  var arrNuvens = [regNuvem]
  arrNuvens.length = 0
  var texto = texto.replace(/	/g, " ") // troca tabs por espaços
  texto = removeEspacosDuplos(texto)
  texto = texto.replace(/\/ /g, "/"); //remove espaços proximos as barras
  texto = texto.replace(/ \//g, "/");
  texto = texto.replace(/ :/g, ":");


  texto = extractSigCld(texto)

  arrSigCld = texto.split(/(?=FT)/g)
  //console.log(arrSigCld)


  //console.log("Antes do %% =>"+texto )
  for (var i in arrNuvensNamesOk) {
    //while (texto.includes()) 
    var str = arrNuvensNamesOk[i]
    //const regex = new RegExp(`ReGeX${str}ReGeX`);

    texto = texto.split(str).join("B%%" + mascaraCBTCU(str))//TODA CAMADA MODIFICADA DEVE SER MASCARADA
  }
  texto = desmascaraCBTCU(texto)

  //console.log("Depois do %% =>"+texto )
  //console.log("Aqui:")
  //console.log(texto)
  camadas = texto.split("B%%")
  //console.log(texto)

  //quebra as validades
  arrValids = getValidades(texto)
  //    if (!arrValids)
  //      arrValids = ["00/00"]
  for (var i in arrValids) {
    var str = arrValids[i].slice(0, -1);
    texto = texto.split(str).join("A%%" + str)
  }

  //console.log(arrValids)
  //console.log(camadas)
  //console.log(texto)

  //if (texto[0] == " ")
  //texto = texto.slice(1)
  camadas = texto.split("A%%")

  //console.log("texto 0 " + texto[0])
  //console.log("quebrou A%%")
  if (camadas[0].length > 10) //se a primeira camada não é validade
    camadas = ["00/00"].concat(camadas)
  //console.log(camadas)

  for (var i in camadas) {
    camadas[i] = camadas[i].split("B%%")
  }
  //console.log(camadas)
  //for (var i = 0; i < )
  for (var i in camadas) {
    if (camadas) {
      if (camadas[i].constructor === Array) {
        for (var j in camadas[i]) {
          //console.log((camadas[i][j]).length)
          if ((camadas[i][j]).includes("FT")) {
            //console.log(i + " - "+ j +" - "+ camadas[i][j])
            let coord = "";

            if (j > 0) { //
              let anterior = camadas[i][j - 1]
              coord = extractCoordNuvem(anterior);
            }
            let camada = camadas[i][j];
            if (camada.includes(" OF ")) // exlclui as coordenadas da proxima camada
              camada = camada.split(" OF ")[0]

            arrNuvens.push(getTetoGamet(camada + " " + coord))
          } else {
            var v = getValidTxt(camadas[i][j] + "")
            if (v.indexOf("/") > 0)
              globalValidadeTeto = v
            //console.log(i + " - "+ j +" - "+v)
          }
        }
      }
    }
  }
  //console.log("sem erros até aqui 1")
  //console.log(arrNuvens)
  arrNuvemFIR[idxFIR] = arrNuvens
  return arrNuvens
}

function NuvensToHtml(arrNuv, idxFIR) {
  var str = ""
  var oldValid = ""//arrNuv[0].validade
  for (var i in arrNuv) {
    var validade = arrNuv[i].validade + " "
    var valido = true

    if (removeEspacos(validade) !== "00/00")
      valido = checaValidadeLinhaGamet(validade)

    validade = validade.replace("00/00", "")
    //console.log(validade)
    if (validade == oldValid)
      validade = ""
    else
      oldValid = validade
    var base = arrNuv[i].base
    var topo = arrNuv[i].topo.replace("FT", "")
    if (validade.includes("/"))
      validade = validade + "</br>"
    var strLocs = " [ " + filtraLocs(arrNuv[i].area, idxFIR) + " ]"
    var idxTeto = '[T' + (parseInt(i) + 1) + '] ';
    if (valido) {
      atualizaStatusTetoGamet(strLocs, base, idxFIR)
      strLocs = spanRed(strLocs, strLocs, "Localidades (dentre as listadas abaixo) que se encontram na área geográfica desta previsão...")
    }
    let linha = validade + idxTeto + " ... " + arrNuv[i].nome + " " + arrNuv[i].base + "/" + topo + "FT ... " + arrNuv[i].area.texto + strLocs + "</br>" // + */// + " " + arrNuv[i].areaStr+ "</br>";
    if (!valido)
      linha = spanGray(linha, linha, "Linha Fora do Intervalo de Validade...")

    str = str + linha
  }
  return str
}


function filtraLocs(area, idxFIR) {
  var str = ""
  for (var i in arrMetaresFiltrados) {
    if (arrMetaresFiltrados[i].FIR == idxFIR) {
      if ((arrMetaresFiltrados[i].latitude >= area.lat1) && (arrMetaresFiltrados[i].latitude <= area.lat0) &&
        (arrMetaresFiltrados[i].longitude >= area.lon1) && (arrMetaresFiltrados[i].longitude <= area.lon0))
        if (!str.includes(arrMetaresFiltrados[i].localidade))
          str = str + " " + arrMetaresFiltrados[i].localidade
    }
  }
  return str
}

function checaValidadeLinhaGamet(valid) {
  valid = valid.split("/")
  let agora = new Date()
  agora = agora.getUTCHours();

  let ini = valid[0]
  let fim = valid[1]

  return (agora >= ini && agora < fim)

}

function updateStatusVisGamet(loc, vis, idxFIR) {
  vis = vis.replace(/[^0-9]/g, "").substr(0, 4)
  let achou = false
  for (let i in arrayStatusGamet) {
    if (arrayStatusGamet[i].loc == loc) {
      achou = true
      if (vis < parseInt(arrayStatusGamet[i].vis)) {
        arrayStatusGamet[i].vis = vis
      }
    }
  }
  if (!achou) {
    arrayStatusGamet.push({ loc: loc, vis: vis, teto: 10000, FIR: idxFIR })
  }

}

function updateStatusTetoGamet(loc, teto, idxFIR) {
  let achou = false
  for (let i in arrayStatusGamet) {
    if (arrayStatusGamet[i].loc == loc) {
      achou = true
      if (teto < parseInt(arrayStatusGamet[i].teto)) {
        arrayStatusGamet[i].teto = teto
      }
    }
  }
  if (!achou) {
    arrayStatusGamet.push({ loc: loc, teto: teto, vis: 9999, FIR: idxFIR })
  }
}

function atualizaStatusVisGamet(locs, vis, idxFIR) {
  //locs = locs.replace(/[^A-Z]/g,"")
  locs = locs.split(" ")

  for (let i in locs) {
    if (locs[i].length == 4) {
      updateStatusVisGamet(locs[i], vis, idxFIR)
    }
  }

}

function atualizaStatusTetoGamet(locs, teto, idxFIR) {
  //locs = locs.replace(/[^A-Z]/g,"")
  locs = locs.split(" ")

  for (let i in locs) {
    if (locs[i].length == 4) {
      updateStatusTetoGamet(locs[i], teto, idxFIR)
    }
  }

}

function getStatusGamet(loc) {
  for (let i in arrayStatusGamet) {
    let item = arrayStatusGamet[i]
    if (item.loc == loc) {

      return {
        vis: arrayStatusGamet[i].vis, teto: arrayStatusGamet[i].teto
      }
    }


  }
}

function VisibToHtml(arrVis, idxFIR) {
  var str = ""
  var oldValid = ""//arrNuv[0].validade


  for (var i in arrVis) {
    if ((arrVis[i].valor) && (arrVis[i].valor !== "undifined")) {
      var validade = arrVis[i].validade + " "
      var textoAreaVis = arrVis[i].area.texto
      var valido = true
      if (removeEspacos(validade) !== "00/00")
        valido = checaValidadeLinhaGamet(validade)
      validade = validade.replace("00/00", "")
      //console.log(validade)
      if (validade == oldValid)
        validade = ""
      else
        oldValid = validade
      var vis = arrVis[i].valor
      if (validade.includes("/"))
        validade = validade + "</br>"
      var idxVis = '[V' + (parseInt(i) + 1) + '] ';
      var strLocs = " [ " + filtraLocs(arrVis[i].area, idxFIR) + " ]"
      if (valido) {
        atualizaStatusVisGamet(strLocs, vis, idxFIR)
        strLocs = spanRed(strLocs, strLocs, "Localidades (dentre as listadas abaixo) que se encontram na área geográfica desta previsão...")
      }

      let linha = validade + idxVis + " ... " + vis + " ... " + textoAreaVis + strLocs + "</br>" // + */// + " " + arrNuv[i].areaStr+ "</br>";
      if (!valido)
        linha = spanGray(linha, linha, "Linha Fora do Intervalo de Validade...")
      str = str + linha
    }
  }
  return str
}

//console.log(texto)
//console.log("Resultado da Visibilidade:")
//console.log(getVisGamet(texto))   
//console.log("Resultado das nuvens:")

//console.log(NuvensToHtml(getNuvensGamet(texto)))
//$("#msg").html(NuvensToHtml(getNuvensGamet(texto)))

function getNuvensHtml(gamet, idxFIR) {
  return NuvensToHtml(getNuvensGamet(gamet, idxFIR), idxFIR)
}

function getVisibHtml(gamet, idxFIR) {
  return VisibToHtml(getVisGamet(gamet, idxFIR), idxFIR)
}



